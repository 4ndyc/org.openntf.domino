/* Generated By:JJTree&JavaCC: Do not edit this line. AtFormulaParser.java */
package de.foconis.test.formula;

import java.io.File;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

import jline.ArgumentCompletor;
import jline.Completor;
import jline.ConsoleReader;
import jline.SimpleCompletor;

import org.openntf.domino.ext.Session.Fixes;
import org.openntf.domino.formula.Formulas;
import org.openntf.domino.formula.Function;
import org.openntf.domino.formula.FunctionFactory;
import org.openntf.domino.formula.module.NotImplemented;
import org.openntf.domino.thread.DominoThread;
import org.openntf.domino.utils.DominoUtils;
import org.openntf.domino.utils.Factory;

public class FormulaShell extends TestRunner {

	public static void main(final String[] args) {
		DominoThread thread = new DominoThread(new FormulaShell(), "My thread");
		thread.start();
	}

	public FormulaShell() {
		// whatever you might want to do in your constructor, but stay away from Domino objects
	}

	@Override
	public void run() {
		try {

			for (Fixes fix : Fixes.values())
				Factory.getSession().setFixEnable(fix, true);
			DominoUtils.setBubbleExceptions(true);

			// RPr: I use  "http://jline.sourceforge.net/" to emulate a shell to test my formula engine
			// I put jline-1.0.jar in jvm/lib/ext
			// In detail: I do not know exactly what I'm doing here... I just need a shell :) 

			ConsoleReader reader = new ConsoleReader();
			reader.setBellEnabled(false);
			//reader.setDebug(new PrintWriter(new FileWriter("writer.debug", true)));

			List<Completor> completors = new LinkedList<Completor>();

			// This code is responsible for autocompletion
			FunctionFactory funcFact = Formulas.getFunctionFactory();
			Collection<Function> funcs = funcFact.getFunctions().values();
			String[] autoComplete = new String[funcs.size() + 3];
			int i = 0;
			for (Function func : funcs) {
				if (func instanceof NotImplemented) {
					autoComplete[i++] = "NotImpl:" + func.getImage();
				} else {
					autoComplete[i++] = func.getImage() + "(";
				}
			}
			autoComplete[i++] = "count=";
			autoComplete[i++] = "astoff";
			autoComplete[i++] = "aston";
			completors.add(new SimpleCompletor(autoComplete));
			reader.addCompletor(new ArgumentCompletor(completors));

			String line;
			// we want some more comfort
			File historyFile = new File("history.txt");
			reader.getHistory().setHistoryFile(historyFile);

			// now start the main loop
			System.out
					.println(NTF("This is the formula shell. Quit with 'q' !!! If you get a NullpointerException, terminate your server!"));
			System.out.println("Session.convertMime is " + LOTUS(Factory.getSession().isConvertMime() ? "enabled" : "disabled"));
			//System.out.println("AST-Cache is " + LOTUS(cacheAST ? "on" : "off"));
			//System.out.println("Iteration count is " + LOTUS(cacheAST ? "on" : "off"));

			while ((line = reader.readLine("$> ")) != null) {
				//				if (line.startsWith("count")) {
				//					int p = line.indexOf('=');
				//					count = Integer.parseInt(line.substring(p + 1));
				//					System.out.println("Iteration count is set to: " + LOTUS(count));
				//					continue;
				//				}
				//				if (line.equalsIgnoreCase("astoff")) {
				//					cacheAST = false;
				//					System.out.println("AST Cache is set to off");
				//					continue;
				//				}

				//				if (line.equalsIgnoreCase("aston")) {
				//					cacheAST = true;
				//					astCache = new HashMap<String, Node>();
				//					System.out.println("AST Cache is set to on");
				//					continue;
				//				}
				if (line.equalsIgnoreCase("q")) {
					break;
				}

				try {
					// disabled lotus!
					execute(line, false, true, true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			System.out.println("Bye.");

		} catch (Exception e) {
			e.printStackTrace();
		}
		//System.out.println(Factory.dumpCounters(true));
		db = null;
		Factory.terminate();
		System.out.println(Factory.dumpCounters(true));
	}

}
