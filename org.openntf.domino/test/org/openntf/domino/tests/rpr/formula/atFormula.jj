/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. atFormula.jj */
/*@egen*//* * \u00c2\u00a9 Copyright FOCONIS AG, 2014 *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at: *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or  * implied. See the License for the specific language governing  * permissions and limitations under the License. */options{  STATIC = false;  JAVA_UNICODE_ESCAPE = false; // Should not pre parse the unicode escape  UNICODE_INPUT = true; // Should accept unicode character from the Reader  JDK_VERSION = "1.5";  IGNORE_CASE = true;                                          }PARSER_BEGIN(AtFormulaParser)package org.openntf.domino.tests.rpr.formula;public class AtFormulaParser/*@bgen(jjtree)*/implements AtFormulaParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTAtFormulaParserState jjtree = new JJTAtFormulaParserState();

/*@egen*/  public static void main(String [] args) throws ParseException, TokenMgrError  {    AtFormulaParser parser = new AtFormulaParser(System.in);    System.out.println("Please type a Lotus domino @formula. Quit with CTRL+Z:");    SimpleNode n = parser.ParseExpressions();    n.dump("");    System.out.println("Thank you.");  }}PARSER_END(AtFormulaParser)/*	public String toString() {		return AdderTreeConstants.jjtNodeName[id] + ": " + jjtGetValue();	}*//** * Lexer rules */// in default mode, a "[" means that the string to the "]" is a Date or Keyword<DEFAULT > TOKEN :{	< Date : "["		 		// Start at [          	(~["]"])*			// until  ]          	"]" > : SUBSCRIPT	// end at ]| 	< Function_Keyword :		"[DROPVOWELS]" | "[NOTRIMWHITE]" | "[ABBREV]"							// @Abstract	| 	"[DST]"																	// @Adjust	| 	"[ALLINRANGE]"															// @Ascii	| 	"[SUBJECT]"	| "[ISSUER]" | "[EXPIRATION]" | "[INTLEXPIRATION]"			// @Certificate	| 	"[CASESENSITIVE]" | "[CASEINSENSITIVE]" | "[ACCENTSENSITIVE]"		| "[ACCENTINSENSITIVE]" | "[PITCHSENSITIVE]" | "[PITCHINSENSITIVE]"		// @Compare 	|	"[FAILSILENT]" | "[PARTIALMATCH]" | "[RETURNDOCUMENTUNIQUEID]"			// @DBLookup 	 	| 	"[AUTOHORZFIT]" | "[AUTOVERTFIT]" | "[NOCANCEL]" | "[NONEWFIELDS]"		| "[NOFIELDUPDATE]" | "[READONLY]" | "[SIZETOTABLE]" | "[NOOKCANCEL]"		| "[OKCANCELATBOTTOM]" | "[NONOTE]"					 					// @Dialogbox (dummo if ever supported)	| 	"[LOCK]" | "[UNLOCK]" | "[STATUS]" | "[LOCKINGENABLED]"					// @DocLock 	| 	"[UPDATE]" | "[NOUPDATE]"												// @DocMark	| 	"[TITLES]" | "[FIRSTONLY]"												// @GetAddressBooks 	|   "[CELLROW]" | "[CELLCOLUMN]" | "[TABLENAME]"							// @GetFocusTable 	| 	"[ENABLED]" | "[DISABLED]"												// @GetPortsList	| 	"[A]" | "[ABBREVIATE]" | "[ADDRESS821]" | "[C]" | "[CANONICALIZE]"		| "[CN]" | "[G]" | "[HIERARCHYONLY]" | "[I]" | "[LP]" | "[O]"		| "[OU1]" | "[OU2]" | "[OU3]" | "[OU4]" | "[P]" | "[PHRASE]"		| "[Q]" | "[S]" | "[TOAT]" | "[TODATATYPE]" | "[TOFIELD]" | "[TOFORM]"		| "[TOKEYWORD]" | "[TOOC]" | "[TOSYNTAX]"								// @Name 	// TODO: List not YET complete		> : SUBSCRIPT}// in subscript mode, a "[" means that the following expression is a subscript// a subscript can occur after a numeric value, a string, a ")", a date, an identifier or an other subscript< SUBSCRIPT >TOKEN :{  	 < OSubscript : "[" > 	:  DEFAULT		// switch back immediately. Thus x[[today]] makes no sense, it is formal correct}< * >TOKEN :{  	// "]" must be recognized in both states  	// consider these examples "x[(1)]": the ) switches to "SUBSCRIPT" 	< CSubscript : "]" > :  SUBSCRIPT	 }< * >TOKEN :{  	// misc tokens	< EOS : ";" >								:	DEFAULT // End of Statement| 	< OParen : "(" >							: 	DEFAULT| 	< CParen : ")" >							: 	SUBSCRIPT // the next open [ means, that this is a subscript| 	< Assign : ":=" >							:	DEFAULT| 	< BoolNot : "!" >							: 	DEFAULT	// Keywords| 	< KW_DEFAULT	: "DEFAULT" >| 	< KW_ENVIRONMENT: "ENVIRONMENT" >| 	< KW_FIELD 		: "FIELD" >| 	< KW_REM 		: "REM" >| 	< KW_SELECT		: "SELECT" >	// @Functions| 	< At_do			: "@do" > | 	< At_doWhile	: "@doWhile" > | 	< At_for		: "@for" > | 	< At_if			: "@if" > | 	< At_iferror	: "@iferror" > | 	< At_transform	: "@transform" > 	// All other at functions that does not control program flow| 	< At_other 	: "@" ( < Letter >  )  (  < Letter >  | < Digit > )*  > : SUBSCRIPT // switch to subscript, to handle @dbname[2]	// Precedence 2| 	< ListConcat : ":" > : DEFAULT	// Precedence 3 (= signs, not listed here)	// < OpPlus : "+" >	// < OpMinus : "-" >			// Precedence 4|	< MultOps :	< OpMul >|< OpMulP >|< OpDiv >|< OpDivP > > : DEFAULT 	| 	< #OpMul : "*" >	| 	< #OpMulP : "**" >	| 	< #OpDiv : "/" >	| 	< #OpDivP : "*/" >	// Precedence 5| 	< OpPlus : "+" > 	: DEFAULT| 	< OpPlusP : "*+" > 	: DEFAULT| 	< OpMinus : "-" > 	: DEFAULT| 	< OpMinusP : "*-" > : DEFAULT	// Precedence 6 - all compare operations|	<  CmpOps :		< CmpEqual > | < CmpEqualP > | <CmpNE > | < CmpNEP > | < CmpLT > | < CmpLTP > |		< CmpGT > | < CmpGTP > | < CmpLTE > | < CmpLTEP > | < CmpGTE > | < CmpGTEP >	> : DEFAULT	|   < #CmpEqual : "=" >	| 	< #CmpEqualP : "*=" >	| 	< #CmpNE : "<>" | "!=" | "=!" | "><" >	| 	< #CmpNEP : "*<>" >	| 	< #CmpLT : "<" >	| 	< #CmpLTP : "*<" >	| 	< #CmpGT : ">" >	| 	< #CmpGTP : "*>" >	| 	< #CmpLTE : "<=" >	| 	< #CmpLTEP : "*<=" >	| 	< #CmpGTE : ">=" >	| 	< #CmpGTEP : "*>=" >		// Precedence 7| 	< BoolAnd : "&" > : DEFAULT| 	< BoolOr : "|" > : DEFAULT	// Numbers: TODO: Why are they locale dependent???|	< NumDoubleUS 	:	(< Digit >)+ "." (< Digit >)+ (< Exponent >)?  | "." (< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< NumDoubleDE 	:	(< Digit >)+ "," (< Digit >)+ (< Exponent >)?  | "," (< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< NumInteger 	: 	(< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< #Exponent: ["e","E"] (["+","-"])? (["0"-"9"])+ >	// Strings| 	< String1 : "\""		 	// Start at "        	(~["\"","\\"] 		// until " or \         	| "\\"				// but not \ (escaped)        	 )*  "\"" > : SUBSCRIPT			// end at "        	 | 	< String2 : "{"		 		// Start at {          	(~["}"])*			// until  }          	"}" >  : SUBSCRIPT	// end at "| 	< Identifier :  ( < Letter >  )  (  < Letter >  | < Digit > )* > : SUBSCRIPT/*// Here all keywords are listed (and the @function where it is used) | 	< Function_Keyword :		"[DROPVOWELS]" | "[NOTRIMWHITE]" | "[ABBREV]"							// @Abstract	| 	"[DST]"																	// @Adjust	| 	"[ALLINRANGE]"															// @Ascii	| 	"[SUBJECT]"	| "[ISSUER]" | "[EXPIRATION]" | "[INTLEXPIRATION]"			// @Certificate	| 	"[CASESENSITIVE]" | "[CASEINSENSITIVE]" | "[ACCENTSENSITIVE]"		| "[ACCENTINSENSITIVE]" | "[PITCHSENSITIVE]" | "[PITCHINSENSITIVE]"		// @Compare 	|	"[FAILSILENT]" | "[PARTIALMATCH]" | "[RETURNDOCUMENTUNIQUEID]"			// @DBLookup 	 	| 	"[AUTOHORZFIT]" | "[AUTOVERTFIT]" | "[NOCANCEL]" | "[NONEWFIELDS]"		| "[NOFIELDUPDATE]" | "[READONLY]" | "[SIZETOTABLE]" | "[NOOKCANCEL]"		| "[OKCANCELATBOTTOM]" | "[NONOTE]"					 					// @Dialogbox (dummo if ever supported)	| 	"[LOCK]" | "[UNLOCK]" | "[STATUS]" | "[LOCKINGENABLED]"					// @DocLock 	| 	"[UPDATE]" | "[NOUPDATE]"												// @DocMark	| 	"[TITLES]" | "[FIRSTONLY]"												// @GetAddressBooks 	|   "[CELLROW]" | "[CELLCOLUMN]" | "[TABLENAME]"							// @GetFocusTable 	| 	"[ENABLED]" | "[DISABLED]"												// @GetPortsList	| 	"[A]" | "[ABBREVIATE]" | "[ADDRESS821]" | "[C]" | "[CANONICALIZE]"		| "[CN]" | "[G]" | "[HIERARCHYONLY]" | "[I]" | "[LP]" | "[O]"		| "[OU1]" | "[OU2]" | "[OU3]" | "[OU4]" | "[P]" | "[PHRASE]"		| "[Q]" | "[S]" | "[TOAT]" | "[TODATATYPE]" | "[TOFIELD]" | "[TOFORM]"		| "[TOKEYWORD]" | "[TOOC]" | "[TOSYNTAX]"								// @Name 	// TODO: List not YET complete		>|	< Date : "["		 		// Start at [          	(~["]"])*			// until  ]          	"]" >				// end at ]*/// Common groups| < #Letter:      [       "$",       "A"-"Z",       "_",       "a"-"z",       "\u00c0"-"\u00d6",       "\u00d8"-"\u00f6",       "\u00f8"-"\u00ff",       "\u0100"-"\u1fff",       "\u3040"-"\u318f",       "\u3300"-"\u337f",       "\u3400"-"\u3d2d",       "\u4e00"-"\u9fff",       "\uf900"-"\ufaff"      ]  >|  < #Digit:      [       "0"-"9",       "\u0660"-"\u0669",       "\u06f0"-"\u06f9",       "\u0966"-"\u096f",       "\u09e6"-"\u09ef",       "\u0a66"-"\u0a6f",       "\u0ae6"-"\u0aef",       "\u0b66"-"\u0b6f",       "\u0be7"-"\u0bef",       "\u0c66"-"\u0c6f",       "\u0ce6"-"\u0cef",       "\u0d66"-"\u0d6f",       "\u0e50"-"\u0e59",       "\u0ed0"-"\u0ed9",       "\u1040"-"\u1049"      ]  >}  < * >SKIP :	{  " "| "\t"| "\n"| "\r"| "\r\n"}/** * Parser rules javacc options *//** * parses expressions. Expressions must not end with ";" (=< EOS >) */public SimpleNode ParseExpressions()       :{/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Root */
        try {
/*@egen*/   	( 		(< EOS >)*	( 		 		< KW_REM > ( <String1 >	| <String2 > ) // AFAIK REMS are only allowed at top level  		  	|	statement() ) 	)* < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {  return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}/** * an expression is one of the 3 "set" keywords (DEFAULT/FIELD/ENVIRONMENT) to set Fields/Env * or an identifier to set a variable. Special case for SELECT  */ private void statement() :{ Token t; }{ //LOOKAHEAD(3) 	< KW_FIELD >/*@bgen(jjtree) SetField */
                                {
                                  ASTSetField jjtn001 = new ASTSetField(JJTSETFIELD);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn001.value = t.image;} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte001) {
                                  if (jjtc001) {
                                    jjtree.clearNodeScope(jjtn001);
                                    jjtc001 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte001 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte001;
                                  }
                                  if (jjte001 instanceof ParseException) {
                                    throw (ParseException)jjte001;
                                  }
                                  throw (Error)jjte001;
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001, true);
                                  }
                                }
/*@egen*/ 		         |  	LOOKAHEAD(2)/*@bgen(jjtree) SetVariable */
                                {
                                  ASTSetVariable jjtn002 = new ASTSetVariable(JJTSETVARIABLE);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn002.value = t.image;} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte002) {
                                  if (jjtc002) {
                                    jjtree.clearNodeScope(jjtn002);
                                    jjtc002 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte002 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte002;
                                  }
                                  if (jjte002 instanceof ParseException) {
                                    throw (ParseException)jjte002;
                                  }
                                  throw (Error)jjte002;
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002, true);
                                  }
                                }
/*@egen*/ 		            | 	< KW_ENVIRONMENT >/*@bgen(jjtree) SetEnvironment */
                                {
                                  ASTSetEnvironment jjtn003 = new ASTSetEnvironment(JJTSETENVIRONMENT);
                                  boolean jjtc003 = true;
                                  jjtree.openNodeScope(jjtn003);
                                }
                                try {
/*@egen*/ 	(t = < Identifier > < Assign > {jjtn003.value = t.image;} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte003) {
                                  if (jjtc003) {
                                    jjtree.clearNodeScope(jjtn003);
                                    jjtc003 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte003 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte003;
                                  }
                                  if (jjte003 instanceof ParseException) {
                                    throw (ParseException)jjte003;
                                  }
                                  throw (Error)jjte003;
                                } finally {
                                  if (jjtc003) {
                                    jjtree.closeNodeScope(jjtn003, true);
                                  }
                                }
/*@egen*/ 		               | 	< KW_DEFAULT >/*@bgen(jjtree) SetDefault */
                                {
                                  ASTSetDefault jjtn004 = new ASTSetDefault(JJTSETDEFAULT);
                                  boolean jjtc004 = true;
                                  jjtree.openNodeScope(jjtn004);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn004.value = t.image;} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte004) {
                                  if (jjtc004) {
                                    jjtree.clearNodeScope(jjtn004);
                                    jjtc004 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte004 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte004;
                                  }
                                  if (jjte004 instanceof ParseException) {
                                    throw (ParseException)jjte004;
                                  }
                                  throw (Error)jjte004;
                                } finally {
                                  if (jjtc004) {
                                    jjtree.closeNodeScope(jjtn004, true);
                                  }
                                }
/*@egen*/ 		           | 	< KW_SELECT >/*@bgen(jjtree) Select */
                      {
                        ASTSelect jjtn005 = new ASTSelect(JJTSELECT);
                        boolean jjtc005 = true;
                        jjtree.openNodeScope(jjtn005);
                      }
                      try {
/*@egen*/ opBool()/*@bgen(jjtree)*/
                      } catch (Throwable jjte005) {
                        if (jjtc005) {
                          jjtree.clearNodeScope(jjtn005);
                          jjtc005 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte005 instanceof RuntimeException) {
                          throw (RuntimeException)jjte005;
                        }
                        if (jjte005 instanceof ParseException) {
                          throw (ParseException)jjte005;
                        }
                        throw (Error)jjte005;
                      } finally {
                        if (jjtc005) {
                          jjtree.closeNodeScope(jjtn005, true);
                        }
                      }
/*@egen*/ 									       | 	opBool()}  /** * boolean ops has the lowest precedence, * ATTENTION: Formula language is the only language I know, where AND and OR has the same precedence! */private void opBool() :{ Token t; }{    opCmp() (    	t = < BoolAnd > opCmp()/*@bgen(jjtree) #OpBool( 2) */
                                {
                                  ASTOpBool jjtn001 = new ASTOpBool(JJTOPBOOL);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                }
                                try {
/*@egen*//*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001,  2);
                                  }
                                }
/*@egen*/	              | 	t = < BoolOr >  opCmp()/*@bgen(jjtree) #OpBool( 2) */
                                {
                                  ASTOpBool jjtn002 = new ASTOpBool(JJTOPBOOL);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*//*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn002,  2);
                                  jjtc002 = false;
                                }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002,  2);
                                  }
                                }
/*@egen*/             )*}/** * before boolean, all compares are evaluated */private void opCmp()  :{ Token t; }{  opAdd()  (t = < CmpOps > opAdd()/*@bgen(jjtree) #OpCmp( 2) */
                                   {
                                     ASTOpCmp jjtn001 = new ASTOpCmp(JJTOPCMP);
                                     boolean jjtc001 = true;
                                     jjtree.openNodeScope(jjtn001);
                                   }
                                   try {
/*@egen*//*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn001,  2);
                                     jjtc001 = false;
                                   }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                   } finally {
                                     if (jjtc001) {
                                       jjtree.closeNodeScope(jjtn001,  2);
                                     }
                                   }
/*@egen*/          )*}/** * next precedence are all add/subtract operations */private void opAdd() :{ Token t; }{    opMult()  (LOOKAHEAD(2)( // lookahead 2 is required, to determine if it is a sign 		t=< OpPlus >		| 	t=< OpPlusP >	| 	t=< OpMinus > 	|	t=< OpMinusP > 	)   opMult()/*@bgen(jjtree) #OpAdd( 2) */
                     {
                       ASTOpAdd jjtn001 = new ASTOpAdd(JJTOPADD);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                     }
                     try {
/*@egen*//*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn001,  2);
                       jjtc001 = false;
                     }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  2);
                       }
                     }
/*@egen*/           )*}/** * highest precedence of operations is multiplication. This is done with a unary list */private void opMult()  :{ Token t; }{  valueList()  ( t = < MultOps > valueList()/*@bgen(jjtree) #OpMult( 2) */
                                              {
                                                ASTOpMult jjtn001 = new ASTOpMult(JJTOPMULT);
                                                boolean jjtc001 = true;
                                                jjtree.openNodeScope(jjtn001);
                                              }
                                              try {
/*@egen*//*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn001,  2);
                                                jjtc001 = false;
                                              }
/*@egen*/  {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                              } finally {
                                                if (jjtc001) {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                }
                                              }
/*@egen*/           )*}/** * one ore more values * for saving mem, unaries are wrapped only in a valueList, if there are more than once */private void valueList() :{}{/*@bgen(jjtree) #ValueList(> 1) */
        {
          ASTValueList jjtn001 = new ASTValueList(JJTVALUELIST);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/	(subscript() (< ListConcat > subscript())* )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/                 }private void subscript() :{}{/*@bgen(jjtree) #Subscript(> 1) */
        {
          ASTSubscript jjtn001 = new ASTSubscript(JJTSUBSCRIPT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/  	(unary()  (< OSubscript > statement() < CSubscript >)*)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/               }private void unary() :{}{ 	< OpPlus > unary() | 	< OpMinus >/*@bgen(jjtree) UnaryNeg */
                    {
                      ASTUnaryNeg jjtn001 = new ASTUnaryNeg(JJTUNARYNEG);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                    }
                    try {
/*@egen*/ unary()/*@bgen(jjtree)*/
                    } catch (Throwable jjte001) {
                      if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte001 instanceof RuntimeException) {
                        throw (RuntimeException)jjte001;
                      }
                      if (jjte001 instanceof ParseException) {
                        throw (ParseException)jjte001;
                      }
                      throw (Error)jjte001;
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001, true);
                      }
                    }
/*@egen*/          | 	< BoolNot >/*@bgen(jjtree) UnaryNot */
                    {
                      ASTUnaryNot jjtn002 = new ASTUnaryNot(JJTUNARYNOT);
                      boolean jjtc002 = true;
                      jjtree.openNodeScope(jjtn002);
                    }
                    try {
/*@egen*/ unary()/*@bgen(jjtree)*/
                    } catch (Throwable jjte002) {
                      if (jjtc002) {
                        jjtree.clearNodeScope(jjtn002);
                        jjtc002 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte002 instanceof RuntimeException) {
                        throw (RuntimeException)jjte002;
                      }
                      if (jjte002 instanceof ParseException) {
                        throw (ParseException)jjte002;
                      }
                      throw (Error)jjte002;
                    } finally {
                      if (jjtc002) {
                        jjtree.closeNodeScope(jjtn002, true);
                      }
                    }
/*@egen*/          // All control flow functions| < At_do >/*@bgen(jjtree) AtDo */
                        {
                          ASTAtDo jjtn003 = new ASTAtDo(JJTATDO);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*/ 		(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte003) {
                          if (jjtc003) {
                            jjtree.clearNodeScope(jjtn003);
                            jjtc003 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte003 instanceof RuntimeException) {
                            throw (RuntimeException)jjte003;
                          }
                          if (jjte003 instanceof ParseException) {
                            throw (ParseException)jjte003;
                          }
                          throw (Error)jjte003;
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003, true);
                          }
                        }
/*@egen*/      | < At_doWhile >/*@bgen(jjtree) AtDoWhile */
                        {
                          ASTAtDoWhile jjtn004 = new ASTAtDoWhile(JJTATDOWHILE);
                          boolean jjtc004 = true;
                          jjtree.openNodeScope(jjtn004);
                        }
                        try {
/*@egen*/ 	(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte004) {
                          if (jjtc004) {
                            jjtree.clearNodeScope(jjtn004);
                            jjtc004 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte004 instanceof RuntimeException) {
                            throw (RuntimeException)jjte004;
                          }
                          if (jjte004 instanceof ParseException) {
                            throw (ParseException)jjte004;
                          }
                          throw (Error)jjte004;
                        } finally {
                          if (jjtc004) {
                            jjtree.closeNodeScope(jjtn004, true);
                          }
                        }
/*@egen*/           | < At_for >/*@bgen(jjtree) AtFor */
                        {
                          ASTAtFor jjtn005 = new ASTAtFor(JJTATFOR);
                          boolean jjtc005 = true;
                          jjtree.openNodeScope(jjtn005);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()	// initialize						< EOS >		statement()	// condition						< EOS >		statement() 	// increment						( < EOS > 	statement() )*	// statements					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte005) {
                          if (jjtc005) {
                            jjtree.clearNodeScope(jjtn005);
                            jjtc005 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte005 instanceof RuntimeException) {
                            throw (RuntimeException)jjte005;
                          }
                          if (jjte005 instanceof ParseException) {
                            throw (ParseException)jjte005;
                          }
                          throw (Error)jjte005;
                        } finally {
                          if (jjtc005) {
                            jjtree.closeNodeScope(jjtn005, true);
                          }
                        }
/*@egen*/       | < At_if >/*@bgen(jjtree) AtIf */
                                {
                                  ASTAtIf jjtn006 = new ASTAtIf(JJTATIF);
                                  boolean jjtc006 = true;
                                  jjtree.openNodeScope(jjtn006);
                                }
                                try {
/*@egen*/			(< OParen >  	statement()	// if						( < EOS > 	statement() < EOS > statement())+	// the elese(if)					 < CParen >)/*@bgen(jjtree)*/
                                } catch (Throwable jjte006) {
                                  if (jjtc006) {
                                    jjtree.clearNodeScope(jjtn006);
                                    jjtc006 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte006 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte006;
                                  }
                                  if (jjte006 instanceof ParseException) {
                                    throw (ParseException)jjte006;
                                  }
                                  throw (Error)jjte006;
                                } finally {
                                  if (jjtc006) {
                                    jjtree.closeNodeScope(jjtn006, true);
                                  }
                                }
/*@egen*/      					 | < At_iferror >/*@bgen(jjtree) AtIfError */
                        {
                          ASTAtIfError jjtn007 = new ASTAtIfError(JJTATIFERROR);
                          boolean jjtc007 = true;
                          jjtree.openNodeScope(jjtn007);
                        }
                        try {
/*@egen*/	(< OParen >  	statement() < EOS > statement() < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte007) {
                          if (jjtc007) {
                            jjtree.clearNodeScope(jjtn007);
                            jjtc007 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte007 instanceof RuntimeException) {
                            throw (RuntimeException)jjte007;
                          }
                          if (jjte007 instanceof ParseException) {
                            throw (ParseException)jjte007;
                          }
                          throw (Error)jjte007;
                        } finally {
                          if (jjtc007) {
                            jjtree.closeNodeScope(jjtn007, true);
                          }
                        }
/*@egen*/           | < At_transform >/*@bgen(jjtree) AtTranform */
                        {
                          ASTAtTranform jjtn008 = new ASTAtTranform(JJTATTRANFORM);
                          boolean jjtc008 = true;
                          jjtree.openNodeScope(jjtn008);
                        }
                        try {
/*@egen*/	(< OParen >  	statement()	// list						< EOS >		statement()	// varName						< EOS >		statement() 	// formula					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte008) {
                          if (jjtc008) {
                            jjtree.clearNodeScope(jjtn008);
                            jjtc008 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte008 instanceof RuntimeException) {
                            throw (RuntimeException)jjte008;
                          }
                          if (jjte008 instanceof ParseException) {
                            throw (ParseException)jjte008;
                          }
                          throw (Error)jjte008;
                        } finally {
                          if (jjtc008) {
                            jjtree.closeNodeScope(jjtn008, true);
                          }
                        }
/*@egen*/            	 | < At_other > formula() | atom()}private void formula()          :{/*@bgen(jjtree) Formula */
  ASTFormula jjtn000 = new ASTFormula(JJTFORMULA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Formula */
  try {
/*@egen*/  {    jjtn000.value = getToken(0).image;  }  // Optional parameters.   ( LOOKAHEAD(2)  	< OParen >    	  statement() ( < EOS > statement() )*    < CParen >  )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/   }private void atom() :{}{   value()| < OParen > statement() <CParen >}/*private void setDefault() #SetDefault :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setEnvironment() #SetEnvironment :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setField() #SetField :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setVariable() #SetVariable :{}{	opBool()	{ jjtThis.value =  getToken(0).image; }}*/private void value()  :{  Token t;}{  	t = < Function_Keyword >/*@bgen(jjtree) Keyword */
        {
          ASTKeyword jjtn001 = new ASTKeyword(JJTKEYWORD);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/  	{ jjtn001.value = t.image; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/         |  	t = < Date >/*@bgen(jjtree) DateValue */
        {
          ASTDateValue jjtn002 = new ASTDateValue(JJTDATEVALUE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002, true);
          jjtc002 = false;
        }
/*@egen*/  	{ jjtn002.value = t.image; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/           	// TODO: Parse date here|	t = < String1 >/*@bgen(jjtree) StringValue */
        {
          ASTStringValue jjtn003 = new ASTStringValue(JJTSTRINGVALUE);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn003, true);
          jjtc003 = false;
        }
/*@egen*/  	{ jjtn003.value = t.image; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/             	// TODO: Encoding|	t = < String2 >/*@bgen(jjtree) StringValue */
        {
          ASTStringValue jjtn004 = new ASTStringValue(JJTSTRINGVALUE);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn004, true);
          jjtc004 = false;
        }
/*@egen*/  	{ jjtn004.value = t.image; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004, true);
          }
        }
/*@egen*/             	// TODO: Encoding|	t = < NumDoubleUS >/*@bgen(jjtree) NumericValue */
        {
          ASTNumericValue jjtn005 = new ASTNumericValue(JJTNUMERICVALUE);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn005, true);
          jjtc005 = false;
        }
/*@egen*/  	{ jjtn005.value = Double.valueOf(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005, true);
          }
        }
/*@egen*/              |	t = < NumDoubleDE >/*@bgen(jjtree) NumericValue */
        {
          ASTNumericValue jjtn006 = new ASTNumericValue(JJTNUMERICVALUE);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn006, true);
          jjtc006 = false;
        }
/*@egen*/  	{ jjtn006.value = Double.valueOf(t.image.replace(',','.')); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006, true);
          }
        }
/*@egen*/              |	t = < NumInteger >/*@bgen(jjtree) IntValue */
        {
          ASTIntValue jjtn007 = new ASTIntValue(JJTINTVALUE);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn007, true);
          jjtc007 = false;
        }
/*@egen*/  	{ jjtn007.value = Long.valueOf(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007, true);
          }
        }
/*@egen*/          |	t = < Identifier >/*@bgen(jjtree) GetVariable */
        {
          ASTGetVariable jjtn008 = new ASTGetVariable(JJTGETVARIABLE);
          boolean jjtc008 = true;
          jjtree.openNodeScope(jjtn008);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn008, true);
          jjtc008 = false;
        }
/*@egen*/  	{ jjtn008.value = t.image; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc008) {
            jjtree.closeNodeScope(jjtn008, true);
          }
        }
/*@egen*/             	}