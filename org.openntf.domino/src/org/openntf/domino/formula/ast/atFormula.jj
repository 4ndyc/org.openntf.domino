/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. atFormula.jj */
/*@egen*/options{  STATIC = false;  JAVA_UNICODE_ESCAPE = false; // Should not pre parse the unicode escape  UNICODE_INPUT = true; // Should accept unicode character from the Reader  JDK_VERSION = "1.5";  IGNORE_CASE = true;                                                                                                                                                                  OUTPUT_DIRECTORY = "..";                                  }PARSER_BEGIN(AtFormulaParserImpl)/* *  \u00c2\u00a9 Copyright FOCONIS AG, 2014 *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at: *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or  * implied. See the License for the specific language governing  * permissions and limitations under the License. */package org.openntf.domino.formula;
import org.openntf.domino.formula.ast.*;
public class AtFormulaParserImpl extends AtFormulaParser/*@bgen(jjtree)*/implements AtFormulaParserImplTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTAtFormulaParserImplState jjtree = new JJTAtFormulaParserImplState();

/*@egen*///  	protected AtFormulaParserImplTokenManager getTokenSource()//  	{//  	  	return token_source;// 	}}PARSER_END(AtFormulaParserImpl)/*	public String toString() {		return AdderTreeConstants.jjtNodeName[id] + ": " + jjtGetValue();	}*/// Comments are allowed (but only in default mode)< DEFAULT, SUBSCRIPT >SKIP :	{  " "| "\t"| "\n"| "\r" | "\r\n"}< DEFAULT, SUBSCRIPT  >SPECIAL_TOKEN : {	<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")?>| 	<FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">| 	<MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">//|   <END_FORMULA : "!>" > : INLINE}/** * Lexer rules */< INLINE > TOKEN :{  	< NORMAL_TEXT :   (~["<"] | "<" ~["!", "#"] | "<!--" )+  >|  	< BEGIN_FORMULA : "<!" > : DEFAULT|   < BEGIN_PSEUDONYM : "<#" >} // in default mode, a "[" means that the string to the "]" is a Date or Keyword< DEFAULT > TOKEN :{	< Date_or_KW : "[" (~["]"])* "]" > : SUBSCRIPT	// after a Date, we are in "subscript" mode (e.g. [Today][1])}// in subscript mode, a "[" means that the following expression is a subscript// a subscript can occur after a numeric value, a string, a ")", a date, an identifier or an other subscript< SUBSCRIPT > TOKEN :{  	 < OSubscript : "[" > 	:  DEFAULT		// switch back immediately. Thus x[[today]] makes no sense, it is formal correct}< DEFAULT, SUBSCRIPT > TOKEN :{  	// "]" must be recognized in both states  	// consider these examples "x[(1)]": the ) switches to "SUBSCRIPT" 	< CSubscript : "]" > :  SUBSCRIPT	 }< DEFAULT, SUBSCRIPT >TOKEN :{  	// misc tokens	< EOS : ";" >								:	DEFAULT // End of Statement| 	< OParen : "(" >							: 	DEFAULT| 	< CParen : ")" >							: 	SUBSCRIPT // the next open [ means, that this is a subscript| 	< Assign : ":=" >							:	DEFAULT| 	< BoolNot : "!" >							: 	DEFAULT	// Keywords| 	< KW_DEFAULT	: "DEFAULT" >| 	< KW_ENVIRONMENT: "ENVIRONMENT" >| 	< KW_FIELD 		: "FIELD" >| 	< KW_REM 		: "REM" >| 	< KW_SELECT		: "SELECT" >// special extension by FOCONIS to define / include custom functions| 	< At_Include	: "@Include" >| 	< At_Function	: "@Function" >	// @Functions| 	< At_do			: "@do" > | 	< At_doWhile	: "@doWhile" > | 	< At_for		: "@for" > | 	< At_if			: "@if" >| 	< At_v2if		: "@V2if" >| 	< At_iferror	: "@iferror" > | 	< At_transform	: "@transform" > | 	< At_sort		: "@sort" >| 	< At_text		: "@text" >| 	< At_eval		: "@eval" >| 	< At_foceval	: "@foceval" >| 	< At_return		: "@return" >| 	< At_iserror	: "@iserror" > 	// All other at functions that does not control program flow| 	< At_other 	: "@" ( < Letter >  )  (  < Letter >  | < Digit > )*  > : SUBSCRIPT // switch to subscript, to handle @dbname[2]	// Precedence 2| 	< ListConcat : ":" > : DEFAULT	// Precedence 3 (= signs, not listed here)	// < OpPlus : "+" >	// < OpMinus : "-" >			// Precedence 4| 	< OpMul : "*" >		: DEFAULT | 	< OpMulP : "**" >	: DEFAULT | 	< OpDiv : "/" >		: DEFAULT | 	< OpDivP : "*/" >	: DEFAULT 	// Precedence 5| 	< OpPlus : "+" > 	: DEFAULT| 	< OpPlusP : "*+" > 	: DEFAULT| 	< OpMinus : "-" > 	: DEFAULT| 	< OpMinusP : "*-" > : DEFAULT	// Precedence 6 - all compare operations|   < CmpEqual : "=" >						: DEFAULT| 	< CmpEqualP : "*=" >					: DEFAULT| 	< CmpNE : "<>" | "!=" | "=!" | "><" >	: DEFAULT| 	< CmpNEP : "*<>" >						: DEFAULT| 	< CmpLT : "<" >							: DEFAULT| 	< CmpLTP : "*<" >						: DEFAULT| 	< CmpGT : ">" >							: DEFAULT| 	< CmpGTP : "*>" >						: DEFAULT| 	< CmpLTE : "<=" >						: DEFAULT| 	< CmpLTEP : "*<=" >						: DEFAULT| 	< CmpGTE : ">=" >						: DEFAULT| 	< CmpGTEP : "*>=" >						: DEFAULT		// Precedence 7| 	< BoolAnd : "&" > : DEFAULT| 	< BoolOr : "|" > : DEFAULT| 	< END_FORMULA : "!>" > : INLINE	// Numbers: TODO: Why are they locale dependent???	// Thousands separator must be avoided!|	< NumDoubleUS 	:	(< Digit >)* "." (< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< NumDoubleDE 	:	(< Digit >)* "," (< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< NumInteger 	: 	(< Digit >)+ ("."|",")? (< Exponent >)? > : SUBSCRIPT | 	< #Exponent: ["e","E"] (["+","-"])? (< Digit >)+ >	// Strings| 	< String1 : "\""		 	// Start at "        	(~["\""] 			// until " or \         	| "\\\""				// but not \ (escaped)        	 )*  "\"" > : SUBSCRIPT			// end at "        	 | 	< String2 : "{"		 		// Start at {          	(~["}"])*			// until  }          	"}" >  : SUBSCRIPT	// end at "| 	< Identifier :  ( < Letter >  )  (  < Letter >  | < Digit > )* > : SUBSCRIPT// Common groups| < #Letter:      [       "$",			// $       "A"-"Z",	// A-Z       "_",			// _       "a"-"z",	// a-z       "~",			// ~       "\u00c0"-"\u00d6",	// \u00c3\u20ac - \u00c3\u2013       "\u00d8"-"\u00f6",	// \u00c3\u02dc - \u00c3\u00b6       "\u00f8"-"\u00ff",	// \u00c3\u00b8 - \u00c3\u00bf       "\u0100"-"\u1fff",	// Latin Extended - A       "\u3040"-"\u318f",	// HIRAGANA/KATAKANA LETTER       "\u3300"-"\u337f",	// CJK Compatibility       "\u3400"-"\u3d2d",	// CJK Unified ideograps Extension A       "\u4e00"-"\u9fff",	// CJK Unified ideograps Extension A       "\uf900"-"\ufaff"	// CJK ... other      ]  >|  < #Digit:      [       "0"-"9"// 	RPr/JSt: only arabic digits are supported       //       "\u0660"-"\u0669",//       "\u06f0"-"\u06f9",//       "\u0966"-"\u096f",//       "\u09e6"-"\u09ef",//       "\u0a66"-"\u0a6f",//       "\u0ae6"-"\u0aef",//       "\u0b66"-"\u0b6f",//       "\u0be7"-"\u0bef",//       "\u0c66"-"\u0c6f",//       "\u0ce6"-"\u0cef",//       "\u0d66"-"\u0d6f",//       "\u0e50"-"\u0e59",//       "\u0ed0"-"\u0ed9",//       "\u1040"-"\u1049"      ]  >}  /** * Parser rules javacc options *//** * parses expressions. Expressions must not end with ";" (=< EOS >) */public SimpleNode parseFormula()       :{/*@bgen(jjtree) AtDo */
  ASTAtDo jjtn000 = new ASTAtDo(this, JJTATDO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) AtDo */
        try {
/*@egen*/	mainStatement() ((< EOS >) mainStatement()	)*	< EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {  return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}public void mainStatement() :{}{(< EOS >)*  	< KW_REM > comment()  // AFAIK REMS are only allowed at top level|	statement()}public SimpleNode parseFocFormula()           :{/*@bgen(jjtree) AtConCat */
  ASTAtConCat jjtn000 = new ASTAtConCat(this, JJTATCONCAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) AtConCat */
        try {
/*@egen*/ 	{ token_source.SwitchTo(INLINE); } 	( normalText() )?   	(		(< BEGIN_FORMULA >			mainStatement() ((< EOS >) mainStatement()	)*		< END_FORMULA > )		( normalText() )?	)*	< EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {  return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}private void normalText()             :{/*@bgen(jjtree) NormalText */
  ASTNormalText jjtn000 = new ASTNormalText(this, JJTNORMALTEXT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }{/*@bgen(jjtree) NormalText */
        try {
/*@egen*/  	t = < NORMAL_TEXT >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/  	{jjtn000.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}private void comment() :{}{		< String1 >	| 	< String2 >	|  	< OParen > comment() < CParen >}/** * an expression is one of the 3 "set" keywords (DEFAULT/FIELD/ENVIRONMENT) to set Fields/Env * or an identifier to set a variable. Special case for SELECT  */ private void statement() :{ Token t; }{ //LOOKAHEAD(3) 	// Include is a custom extension by foconis 	< At_Include >/*@bgen(jjtree) ExtendedInclude */
                                {
                                  ASTExtendedInclude jjtn001 = new ASTExtendedInclude(this, JJTEXTENDEDINCLUDE);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                }
                                try {
/*@egen*/		opBool()/*@bgen(jjtree)*/
                                } catch (Throwable jjte001) {
                                  if (jjtc001) {
                                    jjtree.clearNodeScope(jjtn001);
                                    jjtc001 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte001 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte001;
                                  }
                                  if (jjte001 instanceof ParseException) {
                                    throw (ParseException)jjte001;
                                  }
                                  throw (Error)jjte001;
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001, true);
                                  }
                                }
/*@egen*/	                	// define is a custom extension by foconis 		// @function(@myfunc(a:="x";b:="y");"";| 	< At_Function >/*@bgen(jjtree) ExtendedFunction */
                                {
                                  ASTExtendedFunction jjtn002 = new ASTExtendedFunction(this, JJTEXTENDEDFUNCTION);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*/		(< OParen >							exFuncDef()	(< EOS > exVar())* // followed by optional semicolon and local var defs						< CParen >							( < Assign >  opBool() )?/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn002, true);
                                                  jjtc002 = false;
                                                }
/*@egen*/	 // Assignment is optional						{jjtn002.init();}						)/*@bgen(jjtree)*/
                                } catch (Throwable jjte002) {
                                  if (jjtc002) {
                                    jjtree.clearNodeScope(jjtn002);
                                    jjtc002 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte002 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte002;
                                  }
                                  if (jjte002 instanceof ParseException) {
                                    throw (ParseException)jjte002;
                                  }
                                  throw (Error)jjte002;
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002, true);
                                  }
                                }
/*@egen*/                  |  	< KW_FIELD >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn003 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc003 = true;
                                  jjtree.openNodeScope(jjtn003);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn003.init(t.image, ASTAssignment.FIELD);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte003) {
                                  if (jjtc003) {
                                    jjtree.clearNodeScope(jjtn003);
                                    jjtc003 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte003 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte003;
                                  }
                                  if (jjte003 instanceof ParseException) {
                                    throw (ParseException)jjte003;
                                  }
                                  throw (Error)jjte003;
                                } finally {
                                  if (jjtc003) {
                                    jjtree.closeNodeScope(jjtn003, true);
                                  }
                                }
/*@egen*/ 	           |  	LOOKAHEAD(2)/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn004 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc004 = true;
                                  jjtree.openNodeScope(jjtn004);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn004.init(t.image, ASTAssignment.VAR);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte004) {
                                  if (jjtc004) {
                                    jjtree.clearNodeScope(jjtn004);
                                    jjtc004 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte004 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte004;
                                  }
                                  if (jjte004 instanceof ParseException) {
                                    throw (ParseException)jjte004;
                                  }
                                  throw (Error)jjte004;
                                } finally {
                                  if (jjtc004) {
                                    jjtree.closeNodeScope(jjtn004, true);
                                  }
                                }
/*@egen*/ 	           | 	< KW_ENVIRONMENT >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn005 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc005 = true;
                                  jjtree.openNodeScope(jjtn005);
                                }
                                try {
/*@egen*/ 	(t = < Identifier > < Assign > {jjtn005.init(t.image, ASTAssignment.ENV);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte005) {
                                  if (jjtc005) {
                                    jjtree.clearNodeScope(jjtn005);
                                    jjtc005 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte005 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte005;
                                  }
                                  if (jjte005 instanceof ParseException) {
                                    throw (ParseException)jjte005;
                                  }
                                  throw (Error)jjte005;
                                } finally {
                                  if (jjtc005) {
                                    jjtree.closeNodeScope(jjtn005, true);
                                  }
                                }
/*@egen*/ 	           | 	< KW_DEFAULT >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn006 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc006 = true;
                                  jjtree.openNodeScope(jjtn006);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn006.init(t.image, ASTAssignment.DEFAULT);	} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte006) {
                                  if (jjtc006) {
                                    jjtree.clearNodeScope(jjtn006);
                                    jjtc006 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte006 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte006;
                                  }
                                  if (jjte006 instanceof ParseException) {
                                    throw (ParseException)jjte006;
                                  }
                                  throw (Error)jjte006;
                                } finally {
                                  if (jjtc006) {
                                    jjtree.closeNodeScope(jjtn006, true);
                                  }
                                }
/*@egen*/ 	           | 	< KW_SELECT >/*@bgen(jjtree) Select */
                      {
                        ASTSelect jjtn007 = new ASTSelect(this, JJTSELECT);
                        boolean jjtc007 = true;
                        jjtree.openNodeScope(jjtn007);
                      }
                      try {
/*@egen*/ opBool()/*@bgen(jjtree)*/
                      } catch (Throwable jjte007) {
                        if (jjtc007) {
                          jjtree.clearNodeScope(jjtn007);
                          jjtc007 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte007 instanceof RuntimeException) {
                          throw (RuntimeException)jjte007;
                        }
                        if (jjte007 instanceof ParseException) {
                          throw (ParseException)jjte007;
                        }
                        throw (Error)jjte007;
                      } finally {
                        if (jjtc007) {
                          jjtree.closeNodeScope(jjtn007, true);
                        }
                      }
/*@egen*/ 									       | 	opBool()}  /** * Parameter for extended functions */private void exFuncDef()                      :{/*@bgen(jjtree) ExtendedFunctionDef */
  ASTExtendedFunctionDef jjtn000 = new ASTExtendedFunctionDef(this, JJTEXTENDEDFUNCTIONDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }{/*@bgen(jjtree) ExtendedFunctionDef */
   try {
/*@egen*/   // matches to @myfunc(a:="x";b:="y")   t = < At_other > (< OParen >	exParam() (< EOS > exParam())* < CParen >)?/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/   {jjtn000.init(t.image);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/}/** * Parameter for extended functions */private void exParam()                    :{/*@bgen(jjtree) ExtendedParameter */
  ASTExtendedParameter jjtn000 = new ASTExtendedParameter(this, JJTEXTENDEDPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }{/*@bgen(jjtree) ExtendedParameter */
  try {
/*@egen*/  ( 	LOOKAHEAD(2)  t = < Identifier > 	< Assign > opBool()    | 	t = < Identifier > 	)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {jjtn000.init(t.image);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}  /** * Parameter for extended functions */private void exVar()                   :{/*@bgen(jjtree) ExtendedVariable */
  ASTExtendedVariable jjtn000 = new ASTExtendedVariable(this, JJTEXTENDEDVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }{/*@bgen(jjtree) ExtendedVariable */
  try {
/*@egen*/  ( 	LOOKAHEAD(2)  t = < Identifier > 	< Assign > opBool()    | 	t = < Identifier > 	)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {jjtn000.init(t.image);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}    /** * boolean ops has the lowest precedence, * ATTENTION: Formula language is the only language I know, where AND and OR has the same precedence! */private void opBool() :{ }{  opCmp() (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    (    		< BoolAnd > opCmp()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/ {jjtn001.init("&");	}    	| 	< BoolOr >  opCmp()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/ {jjtn001.init("|");	}  	  	)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/               )*}/** * before boolean, all compares are evaluated */private void opCmp()  :{ }{  opAdd()  (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    (     		< CmpEqual > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.init("=")		;}    	| 	< CmpEqualP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.init("*=")		;}     	| 	< CmpNE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("<>")		;}     	| 	< CmpNEP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("*<>")	;}     	| 	< CmpLT > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("<")		;}     	| 	< CmpLTP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("*<")		;}    	| 	< CmpGT > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init(">")		;}     	| 	< CmpGTP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("*>")		;}     	| 	< CmpLTE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("<=")		;}     	| 	< CmpLTEP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.init("*<=")	;}     	| 	< CmpGTE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init(">=")		;}     	| 	< CmpGTEP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.init("*>=")	;}    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/             )*}/** * next precedence are all add/subtract operations */private void opAdd() :{ }{    opMult()  (LOOKAHEAD(2)/*@bgen(jjtree) #Operator( 2) */
                          {
                            ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
                          }
                          try {
/*@egen*/ ( // lookahead 2 is required, to determine if it is a sign 			< OpPlus >	 	opMult()/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn001,  2);
                                                           jjtc001 = false;
                                                         }
/*@egen*/ {jjtn001.init("+")		;} 		| 	< OpPlusP >		opMult()/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn001,  2);
                                                           jjtc001 = false;
                                                         }
/*@egen*/ {jjtn001.init("*+")	;} 		| 	< OpMinus > 	opMult()/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn001,  2);
                                                   jjtc001 = false;
                                                 }
/*@egen*/ {jjtn001.init("-")		;} 		| 	< OpMinusP > 	opMult()/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn001,  2);
                                                   jjtc001 = false;
                                                 }
/*@egen*/ {jjtn001.init("*-")	;} 	)/*@bgen(jjtree)*/
                          } catch (Throwable jjte001) {
                            if (jjtc001) {
                              jjtree.clearNodeScope(jjtn001);
                              jjtc001 = false;
                            } else {
                              jjtree.popNode();
                            }
                            if (jjte001 instanceof RuntimeException) {
                              throw (RuntimeException)jjte001;
                            }
                            if (jjte001 instanceof ParseException) {
                              throw (ParseException)jjte001;
                            }
                            throw (Error)jjte001;
                          } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  2);
                            }
                          }
/*@egen*/               )*}/** * highest precedence of operations is multiplication. This is done with a unary list */private void opMult()  :{ }{  opSign()  (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    (      		< OpMul > 	opSign()/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                            jjtc001 = false;
                                          }
/*@egen*/  {jjtn001.init("*")	;}     	|	< OpMulP > 	opSign()/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                            jjtc001 = false;
                                          }
/*@egen*/  {jjtn001.init("**")	;}      	| 	< OpDiv > 	opSign()/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                            jjtc001 = false;
                                          }
/*@egen*/  {jjtn001.init("/")	;}      	| 	< OpDivP > 	opSign()/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                            jjtc001 = false;
                                          }
/*@egen*/  {jjtn001.init("*/")	;}	)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/              ) *}private void opSign() :{ }{	opHasSign()|	valueList()}private void opHasSign() :{}{// In N9, the + sign is completely ignored. If you want to be < N6 compatible, feel free to implement that  //	< OpPlus > valueList() {jjtThis.init(" +")	;} #Operator(1)	< OpPlus > valueList()| 	< OpMinus > valueList()/*@bgen(jjtree) #Operator( 1) */
                                {
                                  ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                }
                                try {
/*@egen*//*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  1);
                                  jjtc001 = false;
                                }
/*@egen*/ {jjtn001.init(" -")	;}/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001,  1);
                                  }
                                }
/*@egen*/             }/** * one ore more values * for saving mem, unaries are wrapped only in a valueList, if there are more than once */private void valueList() :{}{/*@bgen(jjtree) #ValueList(> 1) */
        {
          ASTValueList jjtn001 = new ASTValueList(this, JJTVALUELIST);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/	(subscript() (	  		LOOKAHEAD(2)	  		< ListConcat > (opHasSign()| subscript() )	)* )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/                 }private void subscript() :{}{/*@bgen(jjtree) #Subscript(> 1) */
        {
          ASTSubscript jjtn001 = new ASTSubscript(this, JJTSUBSCRIPT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/  	(unary()  (< OSubscript > statement() < CSubscript >)*)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/               }private void unary() :{}{// Attention List operator has a higher precedence. So this is removed here // 		< OpPlus > unary() //| 	< OpMinus > unary() {jjtThis.init(" -")	;} #Operator(1)//|< BoolNot > unary()/*@bgen(jjtree) #Operator( 1) */
                    {
                      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                    }
                    try {
/*@egen*//*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn001,  1);
                      jjtc001 = false;
                    }
/*@egen*/ {jjtn001.init(" !")		;}/*@bgen(jjtree)*/
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  1);
                      }
                    }
/*@egen*/             // All control flow functions| < At_do >/*@bgen(jjtree) AtDo */
                        {
                          ASTAtDo jjtn002 = new ASTAtDo(this, JJTATDO);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                        }
                        try {
/*@egen*/ 		(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002, true);
                          }
                        }
/*@egen*/      | < At_doWhile >/*@bgen(jjtree) AtDoWhile */
                        {
                          ASTAtDoWhile jjtn003 = new ASTAtDoWhile(this, JJTATDOWHILE);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*/ 	(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte003) {
                          if (jjtc003) {
                            jjtree.clearNodeScope(jjtn003);
                            jjtc003 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte003 instanceof RuntimeException) {
                            throw (RuntimeException)jjte003;
                          }
                          if (jjte003 instanceof ParseException) {
                            throw (ParseException)jjte003;
                          }
                          throw (Error)jjte003;
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003, true);
                          }
                        }
/*@egen*/           | < At_for >/*@bgen(jjtree) AtFor */
                        {
                          ASTAtFor jjtn004 = new ASTAtFor(this, JJTATFOR);
                          boolean jjtc004 = true;
                          jjtree.openNodeScope(jjtn004);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()	// initialize						< EOS >		statement()	// condition						< EOS >		statement() 	// increment						( < EOS > 	statement() )*	// statements					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte004) {
                          if (jjtc004) {
                            jjtree.clearNodeScope(jjtn004);
                            jjtc004 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte004 instanceof RuntimeException) {
                            throw (RuntimeException)jjte004;
                          }
                          if (jjte004 instanceof ParseException) {
                            throw (ParseException)jjte004;
                          }
                          throw (Error)jjte004;
                        } finally {
                          if (jjtc004) {
                            jjtree.closeNodeScope(jjtn004, true);
                          }
                        }
/*@egen*/       | (< At_if > | < At_v2if > )/*@bgen(jjtree) AtIf */
                                        {
                                          ASTAtIf jjtn005 = new ASTAtIf(this, JJTATIF);
                                          boolean jjtc005 = true;
                                          jjtree.openNodeScope(jjtn005);
                                        }
                                        try {
/*@egen*/					(< OParen >  	statement()	// if						( < EOS > 	statement() < EOS > statement())+	// the elese(if)					 < CParen >)/*@bgen(jjtree)*/
                                        } catch (Throwable jjte005) {
                                          if (jjtc005) {
                                            jjtree.clearNodeScope(jjtn005);
                                            jjtc005 = false;
                                          } else {
                                            jjtree.popNode();
                                          }
                                          if (jjte005 instanceof RuntimeException) {
                                            throw (RuntimeException)jjte005;
                                          }
                                          if (jjte005 instanceof ParseException) {
                                            throw (ParseException)jjte005;
                                          }
                                          throw (Error)jjte005;
                                        } finally {
                                          if (jjtc005) {
                                            jjtree.closeNodeScope(jjtn005, true);
                                          }
                                        }
/*@egen*/      					 | < At_iferror >/*@bgen(jjtree) AtIfError */
                        {
                          ASTAtIfError jjtn006 = new ASTAtIfError(this, JJTATIFERROR);
                          boolean jjtc006 = true;
                          jjtree.openNodeScope(jjtn006);
                        }
                        try {
/*@egen*/	(< OParen >  	statement() (< EOS > statement())? < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte006) {
                          if (jjtc006) {
                            jjtree.clearNodeScope(jjtn006);
                            jjtc006 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte006 instanceof RuntimeException) {
                            throw (RuntimeException)jjte006;
                          }
                          if (jjte006 instanceof ParseException) {
                            throw (ParseException)jjte006;
                          }
                          throw (Error)jjte006;
                        } finally {
                          if (jjtc006) {
                            jjtree.closeNodeScope(jjtn006, true);
                          }
                        }
/*@egen*/           | < At_transform >/*@bgen(jjtree) AtTransform */
                        {
                          ASTAtTransform jjtn007 = new ASTAtTransform(this, JJTATTRANSFORM);
                          boolean jjtc007 = true;
                          jjtree.openNodeScope(jjtn007);
                        }
                        try {
/*@egen*/	(< OParen >  	statement()	// list						< EOS >		statement()	// varName						< EOS >		statement() 	// formula					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte007) {
                          if (jjtc007) {
                            jjtree.clearNodeScope(jjtn007);
                            jjtc007 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte007 instanceof RuntimeException) {
                            throw (RuntimeException)jjte007;
                          }
                          if (jjte007 instanceof ParseException) {
                            throw (ParseException)jjte007;
                          }
                          throw (Error)jjte007;
                        } finally {
                          if (jjtc007) {
                            jjtree.closeNodeScope(jjtn007, true);
                          }
                        }
/*@egen*/             					 | < At_sort >/*@bgen(jjtree) AtSort */
                        {
                          ASTAtSort jjtn008 = new ASTAtSort(this, JJTATSORT);
                          boolean jjtc008 = true;
                          jjtree.openNodeScope(jjtn008);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()		// list						(< EOS >	statement()		// Options							(< EOS >	statement())? 	// formula						)?					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte008) {
                          if (jjtc008) {
                            jjtree.clearNodeScope(jjtn008);
                            jjtc008 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte008 instanceof RuntimeException) {
                            throw (RuntimeException)jjte008;
                          }
                          if (jjte008 instanceof ParseException) {
                            throw (ParseException)jjte008;
                          }
                          throw (Error)jjte008;
                        } finally {
                          if (jjtc008) {
                            jjtree.closeNodeScope(jjtn008, true);
                          }
                        }
/*@egen*/        | < At_eval >/*@bgen(jjtree) AtEval */
                        {
                          ASTAtEval jjtn009 = new ASTAtEval(this, JJTATEVAL);
                          boolean jjtc009 = true;
                          jjtree.openNodeScope(jjtn009);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()							 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte009) {
                          if (jjtc009) {
                            jjtree.clearNodeScope(jjtn009);
                            jjtc009 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte009 instanceof RuntimeException) {
                            throw (RuntimeException)jjte009;
                          }
                          if (jjte009 instanceof ParseException) {
                            throw (ParseException)jjte009;
                          }
                          throw (Error)jjte009;
                        } finally {
                          if (jjtc009) {
                            jjtree.closeNodeScope(jjtn009, true);
                          }
                        }
/*@egen*/        | < At_foceval >/*@bgen(jjtree) AtFocEval */
                        {
                          ASTAtFocEval jjtn010 = new ASTAtFocEval(this, JJTATFOCEVAL);
                          boolean jjtc010 = true;
                          jjtree.openNodeScope(jjtn010);
                        }
                        try {
/*@egen*/	(< OParen >  	statement()							 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte010) {
                          if (jjtc010) {
                            jjtree.clearNodeScope(jjtn010);
                            jjtc010 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte010 instanceof RuntimeException) {
                            throw (RuntimeException)jjte010;
                          }
                          if (jjte010 instanceof ParseException) {
                            throw (ParseException)jjte010;
                          }
                          throw (Error)jjte010;
                        } finally {
                          if (jjtc010) {
                            jjtree.closeNodeScope(jjtn010, true);
                          }
                        }
/*@egen*/           | < At_text >/*@bgen(jjtree) AtText */
                        {
                          ASTAtText jjtn011 = new ASTAtText(this, JJTATTEXT);
                          boolean jjtc011 = true;
                          jjtree.openNodeScope(jjtn011);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()		// list						(< EOS >	statement())?	// Options					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte011) {
                          if (jjtc011) {
                            jjtree.clearNodeScope(jjtn011);
                            jjtc011 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte011 instanceof RuntimeException) {
                            throw (RuntimeException)jjte011;
                          }
                          if (jjte011 instanceof ParseException) {
                            throw (ParseException)jjte011;
                          }
                          throw (Error)jjte011;
                        } finally {
                          if (jjtc011) {
                            jjtree.closeNodeScope(jjtn011, true);
                          }
                        }
/*@egen*/        | < At_return >/*@bgen(jjtree) AtReturn */
                {
                  ASTAtReturn jjtn012 = new ASTAtReturn(this, JJTATRETURN);
                  boolean jjtc012 = true;
                  jjtree.openNodeScope(jjtn012);
                }
                try {
/*@egen*/ (< OParen >  statement() < CParen >)/*@bgen(jjtree)*/
                } catch (Throwable jjte012) {
                  if (jjtc012) {
                    jjtree.clearNodeScope(jjtn012);
                    jjtc012 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte012 instanceof RuntimeException) {
                    throw (RuntimeException)jjte012;
                  }
                  if (jjte012 instanceof ParseException) {
                    throw (ParseException)jjte012;
                  }
                  throw (Error)jjte012;
                } finally {
                  if (jjtc012) {
                    jjtree.closeNodeScope(jjtn012, true);
                  }
                }
/*@egen*/          | < At_iserror >/*@bgen(jjtree) AtIsError */
                 {
                   ASTAtIsError jjtn013 = new ASTAtIsError(this, JJTATISERROR);
                   boolean jjtc013 = true;
                   jjtree.openNodeScope(jjtn013);
                 }
                 try {
/*@egen*/ (< OParen >  statement() < CParen >)/*@bgen(jjtree)*/
                 } catch (Throwable jjte013) {
                   if (jjtc013) {
                     jjtree.clearNodeScope(jjtn013);
                     jjtc013 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte013 instanceof RuntimeException) {
                     throw (RuntimeException)jjte013;
                   }
                   if (jjte013 instanceof ParseException) {
                     throw (ParseException)jjte013;
                   }
                   throw (Error)jjte013;
                 } finally {
                   if (jjtc013) {
                     jjtree.closeNodeScope(jjtn013, true);
                   }
                 }
/*@egen*/            | < At_other > formula() | atom()}private void formula()           :{/*@bgen(jjtree) Function */
  ASTFunction jjtn000 = new ASTFunction(this, JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }{/*@bgen(jjtree) Function */
  try {
/*@egen*/  { t = getToken(0); }  // Optional parameters.   ( LOOKAHEAD(2)  	< OParen >    	  statement() ( < EOS > statement() )*    < CParen >  )?/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/    { jjtn000.init(t.image); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}private void atom() :{}{   value()| < OParen > statement() <CParen >}/*private void setDefault() #SetDefault :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setEnvironment() #SetEnvironment :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setField() #SetField :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setVariable() #SetVariable :{}{	opBool()	{ jjtThis.value =  getToken(0).image; }}*/private void value()  :{  Token t;}{  	t = < Date_or_KW >/*@bgen(jjtree) ValueDateOrKW */
        {
          ASTValueDateOrKW jjtn001 = new ASTValueDateOrKW(this, JJTVALUEDATEORKW);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/  	{ jjtn001.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/               |	t = < String1 >/*@bgen(jjtree) ValueString */
        {
          ASTValueString jjtn002 = new ASTValueString(this, JJTVALUESTRING);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002, true);
          jjtc002 = false;
        }
/*@egen*/  	{ jjtn002.parseString(t.image, '"'); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/             |	t = < String2 >/*@bgen(jjtree) ValueString */
        {
          ASTValueString jjtn003 = new ASTValueString(this, JJTVALUESTRING);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn003, true);
          jjtc003 = false;
        }
/*@egen*/  	{ jjtn003.parseString(t.image, '{' ); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/             |	t = < NumDoubleUS >/*@bgen(jjtree) ValueDouble */
        {
          ASTValueDouble jjtn004 = new ASTValueDouble(this, JJTVALUEDOUBLE);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn004, true);
          jjtc004 = false;
        }
/*@egen*/  	{ jjtn004.parseDouble(t.image,'.'); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004, true);
          }
        }
/*@egen*/             |	t = < NumDoubleDE >/*@bgen(jjtree) ValueDouble */
        {
          ASTValueDouble jjtn005 = new ASTValueDouble(this, JJTVALUEDOUBLE);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn005, true);
          jjtc005 = false;
        }
/*@egen*/  	{ jjtn005.parseDouble(t.image,','); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005, true);
          }
        }
/*@egen*/             |	t = < NumInteger >/*@bgen(jjtree) ValueInt */
        {
          ASTValueInt jjtn006 = new ASTValueInt(this, JJTVALUEINT);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn006, true);
          jjtc006 = false;
        }
/*@egen*/  	{ jjtn006.parseInt(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006, true);
          }
        }
/*@egen*/          |	t = < Identifier >/*@bgen(jjtree) GetVariable */
        {
          ASTGetVariable jjtn007 = new ASTGetVariable(this, JJTGETVARIABLE);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn007, true);
          jjtc007 = false;
        }
/*@egen*/  	{ jjtn007.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007, true);
          }
        }
/*@egen*/             	}